import pandas as pd
import numpy as np
import os
from datetime import timedelta
from scipy.optimize import minimize
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import warnings
# --- è¾…åŠ©è®¾ç½®ï¼ˆä¿æŒä¸å˜ï¼‰ ---
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# -----------------------------

class CSIPortfolioAnalysis:
    def __init__(self, data_path):
        self.data_path = data_path
        self.adjustment_dates = None
        self.price_data = None
        self.constituent_data = None
        # ç®€åŒ–ç‰ˆï¼šä»…åŠ è½½å›æµ‹æ‰€éœ€çš„2023å¹´åŠä¹‹åæ•°æ®
        self.price_files = {
            'å¿«ç…§1':'ä¸­è¯500æˆåˆ†è‚¡æ•°æ®-å¿«ç…§1.xlsx'
        }

    # --- æ•°æ®åŠ è½½æ–¹æ³•ï¼ˆç²¾ç®€ç»“æ„ï¼Œä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼‰ ---

    def load_adjustment_dates(self):
        """åŠ è½½æˆåˆ†è‚¡è°ƒæ•´æ—¥æœŸ"""
        file_path = os.path.join(self.data_path, "ä¸­è¯500æˆåˆ†è‚¡æ•°æ®-å¿«ç…§1.xlsx")
        try:
            adj_df = pd.read_excel(file_path, sheet_name='è°ƒæ•´æ—¥æœŸæ±‡æ€»')
            # ç®€åŒ–æ—¥æœŸè§£æ
            adj_df['ç”Ÿæ•ˆæ—¥æœŸ'] = pd.to_datetime(adj_df['ç”Ÿæ•ˆæ—¥æœŸ'], errors='coerce')
            adj_df = adj_df.dropna(subset=['ç”Ÿæ•ˆæ—¥æœŸ'])

            dates_map = {
                f"{row['å¹´ä»½']}-{int(row['æœˆä»½']):02d}": row['ç”Ÿæ•ˆæ—¥æœŸ']
                for _, row in adj_df.iterrows()
                if 'å·²è·å–' in str(row.get('çŠ¶æ€', ''))
            }
            self.adjustment_dates = dict(sorted(dates_map.items(), key=lambda x: x[1]))
        except Exception as e:
            print(f"åŠ è½½è°ƒæ•´æ—¥æœŸå¤±è´¥: {e}")

    def load_all_price_data(self):
        """åŠ è½½æ‰€æœ‰ä»·æ ¼æ•°æ®å¹¶åˆå¹¶"""
        all_prices = []
        for filename in self.price_files.values():
            try:
                df = pd.read_excel(os.path.join(self.data_path, filename), sheet_name='Sheet1', header=0)
                df = df.iloc[1:].set_index(df.columns[0])
                df.index = pd.to_datetime(df.index)
                all_prices.append(df)
            except Exception as e:
                print(f"åŠ è½½ {filename} å¤±è´¥: {e}")

        if all_prices:
            self.price_data = pd.concat(all_prices, axis=0)
            self.price_data = self.price_data.sort_index().loc[~self.price_data.index.duplicated(keep='first')]
        print(analyzer.price_data.shape)

    def load_constituent_data(self):
        """åŠ è½½æˆåˆ†è‚¡çŠ¶æ€çŸ©é˜µ"""
        file_path = os.path.join(self.data_path, "ä¸­è¯500æˆåˆ†è‚¡æ•°æ®-å¿«ç…§1.xlsx")
        try:
            df = pd.read_excel(file_path, sheet_name='æˆåˆ†è‚¡çŠ¶æ€çŸ©é˜µ', header=0)
            index_col_name = df.columns[14]
            self.constituent_data = df.set_index(index_col_name)
        except Exception as e:
            print(f"åŠ è½½æˆåˆ†è‚¡æ•°æ®å¤±è´¥: {e}")

    # --- æ ¸å¿ƒå·¥å…·æ–¹æ³• ---

    def calculate_log_returns(self, prices):
        """è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡"""
        prices = prices.apply(pd.to_numeric, errors='coerce').ffill()
        return np.log(prices / prices.shift(1)).dropna(how='all')

    def get_constituents_by_date(self, target_date):
        """æ ¹æ®æ—¥æœŸè·å–ç”Ÿæ•ˆçš„æˆåˆ†è‚¡åˆ—è¡¨"""
        ###è¿™ä¸ªå‡½æ•°å¯ä»¥æ‰¾åˆ°å…ˆå‰çš„äº¤æ˜“æ—¥æœŸ
        if self.constituent_data is None or self.adjustment_dates is None: print("é”™è¯¯1")

        target_date = pd.to_datetime(target_date)
        prev_adj = next((d for d in reversed(self.adjustment_dates.values()) if d <= target_date), None)
        ##nextæ„ä¸ºæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¡ä»¶å°±åœæ­¢æœç´¢
        if prev_adj is None: print("æ²¡æœ‰æ‰¾åˆ°å…ˆå‰è°ƒæ•´æ—¥")

        adj_key = next(k for k, v in self.adjustment_dates.items() if v == prev_adj)
        target_col_name = f"æ˜¯å¦æˆåˆ†è‚¡_{adj_key}"
        print("æˆåˆ†è‚¡è°ƒæ•´æ—¥æœŸ",target_col_name)

        if target_col_name in self.constituent_data.columns:
            constituents = self.constituent_data[self.constituent_data[target_col_name] == 1].index.tolist()
            # ç®€åŒ–ä»£ç åŒ¹é…é€»è¾‘
            available_stocks = [
                s for s in constituents
                if s in self.price_data.columns or s.replace('sh.', '').replace('sz.', '') in self.price_data.columns
            ]
            return available_stocks
            print("å¯è·å¾—è‚¡ç¥¨ä¸º:",available_stocks)
        else:print("é”™è¯¯2")
        return []

    def estimate_parameters_rolling(self, end_date, lookback_days=180):
        """æ»šåŠ¨ä¼°è®¡å‡å€¼å’Œåæ–¹å·®çŸ©é˜µ"""
        constituents = self.get_constituents_by_date(end_date)
        if not constituents: print("æ²¡æœ‰æ—¥æœŸçš„ç»„æˆæˆåˆ†")

        start_dt = end_date - timedelta(days=lookback_days)
        period_prices = self.price_data[constituents].loc[start_dt:end_date].dropna(axis=1, how='all')
        print(f"ç­›é€‰åä»·æ ¼æ•°æ®å½¢çŠ¶: {period_prices.shape}")

        if period_prices.shape[0] < 180: print("æ•°æ®ä¸è¶³180å¤©")

        # returns = self.calculate_log_returns(period_prices).dropna(axis=1) è¿™ä¸ªä¸èƒ½åˆ 
        returns = self.calculate_log_returns(period_prices)
        if returns.empty: return None, None, []

        mean_returns = returns.mean()
        cov_matrix = returns.cov()

        # å¢åŠ åæ–¹å·®çŸ©é˜µçš„æ•°å€¼ç¨³å®šæ€§æ£€æŸ¥ (é˜²æ­¢ä¼˜åŒ–å¤±è´¥)
        if np.linalg.cond(cov_matrix) > 1e10:
            np.fill_diagonal(cov_matrix.values, cov_matrix.values.diagonal() + 1e-6)

        if mean_returns.isnull().any() or cov_matrix.isnull().any().any(): print("æ²¡æœ‰åæ–¹å·®é˜µ")

        return mean_returns, cov_matrix, returns.columns.tolist()

    # --- ç­–ç•¥ä¼˜åŒ–æ–¹æ³•ï¼ˆä¿æŒæ ¸å¿ƒé€»è¾‘ï¼‰ ---
    def markowitz_max_sharpe(self, mean_returns, cov_matrix, risk_free_rate=0.02, annual_factor=252):
        n = len(mean_returns)

        def neg_sharpe(w):
            r = np.dot(w, mean_returns) * annual_factor ###å› ä¸ºæ˜¯å¯¹æ•°æ”¶ç›Šç‡
            vol = np.sqrt(np.dot(w.T, np.dot(cov_matrix, w))) * np.sqrt(annual_factor)  ##å¹´æ³¢åŠ¨ç‡
            return -(r - risk_free_rate) / vol

        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
        bounds = tuple((0, 1) for _ in range(n))
        initial_weights = n * [1.0 / n]

        result = minimize(neg_sharpe, initial_weights, method='SLSQP', bounds=bounds, constraints=constraints)
        return result.x if result.success else None

    def markowitz_min_risk(self, mean_returns, cov_matrix, annual_factor=252):
        n = len(mean_returns)

        def portfolio_vol(w):
            return np.sqrt(np.dot(w.T, np.dot(cov_matrix, w))) * np.sqrt(annual_factor)

        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
        bounds = tuple((0, 1) for _ in range(n))
        initial_weights = n * [1.0 / n]

        result = minimize(portfolio_vol, initial_weights, method='SLSQP', bounds=bounds, constraints=constraints)
        return result.x if result.success else None

    def risk_parity(self, cov_matrix):
        n = len(cov_matrix)

        def rp_objective(w):
            w = np.array(w)
            if np.any(w < 0): print("é£é™©å¹³ä»·æƒé‡å°äº0")

            portfolio_vol = np.sqrt(np.dot(w.T, np.dot(cov_matrix, w))) * np.sqrt(252) ##è¿˜æ˜¯ç”¨å¹´æ³¢åŠ¨ç‡

            # ğŸ’¡ å¢åŠ é˜²é™¤é›¶æ£€æŸ¥
            if portfolio_vol < 1e-12: print("é£é™©å¹³ä»·æ³¢åŠ¨ç‡å¤ªä½")

            risk_contributions = w * (np.dot(cov_matrix, w) / portfolio_vol)
            target_rc = portfolio_vol / n
            return np.sum((risk_contributions - target_rc) ** 2)

        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
        bounds = tuple((0, 1) for _ in range(n))
        initial_weights = n * [1.0 / n]

        result = minimize(rp_objective, initial_weights, method='SLSQP', bounds=bounds, constraints=constraints,
                          tol=1e-6)
        return result.x if result.success else None

    def equal_weight(self, mean_returns, cov_matrix=None):
        return np.ones(len(mean_returns)) / len(mean_returns)

    def market_cap_weight(self, mean_returns, cov_matrix=None):
        # ç®€åŒ–ç‰ˆï¼šç”¨ç­‰æƒä»£æ›¿
        return self.equal_weight(mean_returns)

    def backtest_portfolio(self, start_date='2023-01-01', end_date='2025-09-30'):
        if self.price_data is None or self.price_data.empty:
            return None

        # è°ƒä»“æ—¥æœŸï¼ˆæ¯3ä¸ªæœˆä¸€æ¬¡ï¼‰
        rebalance_dates_str = ['2023-01-01', '2023-04-01', '2023-07-01', '2023-10-01',
                               '2024-01-01', '2024-04-01', '2024-07-01', '2024-10-01',
                               '2025-01-01', '2025-04-01', '2025-07-01']
        rebalance_dates = [pd.to_datetime(d) for d in rebalance_dates_str]

        # ä½¿ç”¨æ‰€æœ‰äº¤æ˜“æ—¥ï¼Œè¿™æ ·æ‰èƒ½æ¯æ—¥è®¡ç®—å‡€å€¼
        trading_dates = self.price_data.index[
            (self.price_data.index >= pd.to_datetime(start_date)) &
            (self.price_data.index <= pd.to_datetime(end_date))
            ]

        strategies = {
            'max_sharpe': self.markowitz_max_sharpe,
            'min_variance': self.markowitz_min_risk,
            'equal_weight': self.equal_weight,
            'risk_parity': self.risk_parity,
            'market_cap': self.market_cap_weight
        }

        portfolio_values = {name: 1 for name in strategies}
        cumulative_returns = {name: pd.Series(dtype=float) for name in strategies}
        current_weights = {name: {} for name in strategies}

        for i, date in enumerate(trading_dates):

            # è°ƒä»“é€»è¾‘ï¼šåªåœ¨è°ƒä»“æ—¥é‡æ–°è®¡ç®—æƒé‡ï¼ˆæ¯3ä¸ªæœˆä¸€æ¬¡ï¼‰
            if date in rebalance_dates:
                print(f"=== è°ƒä»“æ—¥: {date.strftime('%Y-%m-%d')} ===")

                mean_returns, cov_matrix, stocks_used = self.estimate_parameters_rolling(
                    date, lookback_days=180
                )

                if mean_returns is not None:
                    print(f"å¯æŠ•èµ„è‚¡ç¥¨æ•°é‡: {len(stocks_used)}")
                    for name, func in strategies.items():
                        try:
                            weights = None
                            if name == 'risk_parity':
                                weights = func(cov_matrix)
                            elif name in ['max_sharpe', 'min_variance']:
                                weights = func(mean_returns, cov_matrix)
                            else:
                                weights = func(mean_returns)

                            if weights is not None:
                                new_weights = {k: v for k, v in zip(stocks_used, weights) if v > 1e-6}
                                total_weight = sum(new_weights.values())
                                if total_weight > 0:
                                    current_weights[name] = {k: v / total_weight for k, v in new_weights.items()}
                                    print(f"{name}: é…ç½®{len(new_weights)}åªè‚¡ç¥¨")
                            else:
                                print(f"{name}: ä¼˜åŒ–å¤±è´¥")
                        except Exception as e:
                            print(f"{name} ç­–ç•¥ä¼˜åŒ–å¤±è´¥: {e}")
                else:
                    print("å‚æ•°ä¼°è®¡å¤±è´¥ï¼Œä¿æŒåŸæœ‰æƒé‡")

            # æ¯æ—¥è®¡ç®—å‡€å€¼ï¼ˆæ¯å¤©éƒ½è¦æ‰§è¡Œï¼‰
            if i > 0:
                yesterday = trading_dates[i - 1]

                # è®¡ç®—æ‰€æœ‰è‚¡ç¥¨çš„ä»·æ ¼å˜åŒ–
                price_change = self.price_data.loc[date] / self.price_data.loc[yesterday]

                for name in strategies:
                    weights = current_weights[name]

                    if weights and len(weights) > 0:
                        portfolio_stocks = list(weights.keys())

                        # è·å–æŠ•èµ„ç»„åˆä¸­è‚¡ç¥¨çš„å®é™…ä»·æ ¼å˜åŒ–
                        relevant_changes = price_change.loc[
                            price_change.index.intersection(portfolio_stocks)
                        ].dropna()

                        if len(relevant_changes) > 0:
                            # å¯¹é½æƒé‡
                            aligned_weights = pd.Series(weights).loc[relevant_changes.index]
                            weight_sum = aligned_weights.sum()

                            if weight_sum > 0:
                                aligned_weights = aligned_weights / weight_sum
                                daily_return_factor = np.dot(aligned_weights.values, relevant_changes.values)
                                portfolio_values[name] *= daily_return_factor
                        # å¦‚æœæ²¡æœ‰ç›¸å…³æ•°æ®ï¼Œå‡€å€¼ä¿æŒä¸å˜
                    else:
                        # å¦‚æœæ²¡æœ‰æƒé‡ï¼ˆå¦‚ç¬¬ä¸€å¤©æˆ–ä¼˜åŒ–å¤±è´¥ï¼‰ï¼Œå‡€å€¼ä¿æŒä¸å˜
                        pass

                    # è®°å½•æ¯æ—¥å‡€å€¼
                    cumulative_returns[name].loc[date] = portfolio_values[name]

            elif date == trading_dates[0]:
                # ç¬¬ä¸€å¤©ï¼Œè®°å½•åˆå§‹å‡€å€¼
                for name in strategies:
                    cumulative_returns[name].loc[date] = portfolio_values[name]

        # è½¬æ¢ä¸ºæ”¶ç›Šç‡ç™¾åˆ†æ¯”
        results_df = pd.DataFrame(cumulative_returns)
        return (results_df - 1) * 100

def plot_portfolio_performance(results_df):
    """ç»˜åˆ¶æŠ•èµ„ç»„åˆç´¯ç§¯æ”¶ç›Šç‡å›¾è¡¨"""
    if results_df is None or results_df.empty:
        print("æ²¡æœ‰å¯ç”¨äºç»˜åˆ¶çš„æŠ•èµ„ç»„åˆå›æµ‹ç»“æœã€‚")
        return

    # è°ƒè¯•ä¿¡æ¯
    print(f"å›æµ‹ç»“æœæ•°æ®å½¢çŠ¶: {results_df.shape}")
    print(f"å›æµ‹ç»“æœåˆ—å: {results_df.columns.tolist()}")
    print(f"æ—¶é—´èŒƒå›´: {results_df.index.min()} åˆ° {results_df.index.max()}")

    # è®¾ç½®å›¾å½¢
    plt.figure(figsize=(14, 8))

    # ç­–ç•¥é¢œè‰²å’Œæ ‡ç­¾æ˜ å°„
    strategy_config = {
        'max_sharpe': {'color': 'red', 'label': 'æœ€å¤§å¤æ™®æ¯”ç‡', 'linestyle': '-'},
        'min_variance': {'color': 'blue', 'label': 'æœ€å°æ–¹å·®', 'linestyle': '--'},
        'equal_weight': {'color': 'green', 'label': 'ç­‰æƒé‡', 'linestyle': '-.'},
        'risk_parity': {'color': 'orange', 'label': 'é£é™©å¹³ä»·', 'linestyle': ':'},
        'market_cap': {'color': 'purple', 'label': 'å¸‚å€¼åŠ æƒ', 'linestyle': '-'}
    }

    # ç»˜åˆ¶æ¯æ¡æ›²çº¿
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            data = results_df[strategy].dropna()
            if len(data) > 0:
                plt.plot(data.index, data.values,
                         color=config['color'],
                         label=config['label'],
                         linestyle=config['linestyle'],
                         linewidth=2,
                         marker='o' if len(data) < 10 else '',  # æ•°æ®ç‚¹å°‘æ—¶æ˜¾ç¤ºæ ‡è®°ç‚¹
                         markersize=4)

    # è®¾ç½®å›¾è¡¨æ ·å¼
    plt.title('æŠ•èµ„ç»„åˆç´¯ç§¯æ”¶ç›Šç‡ï¼ˆ2023-2025ï¼‰', fontsize=16, fontweight='bold', pad=20)
    plt.xlabel('æ—¥æœŸ', fontsize=12)
    plt.ylabel('ç´¯ç§¯æ”¶ç›Šç‡ (%)', fontsize=12)
    plt.legend(fontsize=10, loc='best')
    plt.grid(True, alpha=0.3)
    # plt.grid(False)

    # è®¾ç½®xè½´æ—¥æœŸæ ¼å¼
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    if len(results_df) > 50:  # æ•°æ®ç‚¹å¤šæ—¶æ¯6ä¸ªæœˆæ˜¾ç¤ºä¸€ä¸ªæ ‡ç­¾
        plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
    else:  # æ•°æ®ç‚¹å°‘æ—¶æ¯ä¸ªæœˆæ˜¾ç¤ºä¸€ä¸ªæ ‡ç­¾
        plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=3))
    plt.gcf().autofmt_xdate()  # è‡ªåŠ¨æ—‹è½¬æ—¥æœŸæ ‡ç­¾

    # æ·»åŠ æ”¶ç›Šç‡ä¸º0çš„å‚è€ƒçº¿
    plt.axhline(y=0, color='black', linestyle='-', alpha=0.3, linewidth=1)

    # æ˜¾ç¤ºå›¾è¡¨
    plt.tight_layout()
    plt.show()

    # è¾“å‡ºæœ€ç»ˆæ”¶ç›Šç‡ç»Ÿè®¡
    print("\nå„ç­–ç•¥æœ€ç»ˆç´¯ç§¯æ”¶ç›Šç‡ç»Ÿè®¡ï¼š")
    final_returns = {}
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            final_return = results_df[strategy].iloc[-1] if not results_df[strategy].isna().all() else None
            if final_return is not None:
                final_returns[config['label']] = final_return

    if final_returns:
        for label, final_return in sorted(final_returns.items(), key=lambda item: item[1], reverse=True):
            print(f"{label}: {final_return:.2f}%")
    else:
        print("æ²¡æœ‰æœ‰æ•ˆçš„æ”¶ç›Šç‡æ•°æ®")

if __name__ == "__main__":
    # è¯·ç¡®ä¿æ­¤è·¯å¾„æ­£ç¡®ä¸”åŒ…å«æ‰€æœ‰æ–‡ä»¶
    data_path = r"C:\Users\cufet\Desktop\æµ‹è¯•é›†"

    try:
        analyzer = CSIPortfolioAnalysis(data_path)

        print("--- æ­¥éª¤ 1: æ•°æ®åŠ è½½ ---")
        analyzer.load_adjustment_dates()
        analyzer.load_all_price_data()
        analyzer.load_constituent_data()

        if analyzer.price_data is None or analyzer.constituent_data is None:
            print("æ•°æ®åŠ è½½å¤±è´¥ï¼Œæ— æ³•è¿›è¡Œå›æµ‹ã€‚")
            portfolio_results_df = None
        else:
            print("--- æ­¥éª¤ 2: æŠ•èµ„ç»„åˆå›æµ‹ ---")
            portfolio_results_df = analyzer.backtest_portfolio(
                start_date='2023-01-01',
                end_date='2025-09-30'
            )

        if portfolio_results_df is not None:
            plot_portfolio_performance(portfolio_results_df)

    except Exception as e:
        print(f"åˆ†æè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
