import pandas as pd
import numpy as np
import os
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
# 使用 TkAgg 后端确保绘图正常显示
# 注意：在某些环境中 (例如没有图形界面的服务器或在线Notebook)，
# 'TkAgg'可能不起作用，您可能需要改为 'Agg' 或删除此行，
# 但对于本地测试，'TkAgg'是常用选择。
# 已经在原代码中设置：matplotlib.use('TkAgg')

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import warnings
from datetime import timedelta

# --- 辅助设置 ---
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


class SimplePortfolioBacktester:
    # 增加 hs300_data_file 参数
    def __init__(self, data_path, stock_data_file, csi_data_file, hs300_data_file):
        self.data_path = data_path
        self.stock_data_file = stock_data_file
        self.csi_data_file = csi_data_file
        self.hs300_data_file = hs300_data_file  # 新增沪深300文件

        self.price_data = None
        self.custom_matrix = None
        self.csi500_returns = None
        self.hs300_returns = None  # 沪深300收益率

        # 新增：存储计算的指标结果
        self.metrics_results = {}

        # 交易成本设置
        self.initial_capital = 10000000  # 初始资金10亿
        self.buy_fee = 0.0003  # 买入费率 0.03% (万3)
        self.sell_fee = 0.0013  # 卖出费率 0.05% (万5)

        self._load_all_data()

    def _load_all_data(self):
        """加载所有数据：股票价格、自定义组合矩阵、中证500指数、沪深300指数。"""

        # 1. 加载股票收盘价 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='全部数据', header=0)
            df = df.iloc[1:].set_index(df.columns[0])
            df.index = pd.to_datetime(df.index)
            df.columns = df.columns.astype(str)
            self.price_data = df.apply(pd.to_numeric, errors='coerce').ffill()
            print(f"股票价格数据形状: {self.price_data.shape}")
        except Exception as e:
            print(f"加载股票价格数据失败: {e}")
            self.price_data = pd.DataFrame()

        # 2. 加载自定义组合状态矩阵 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='Sheet2', header=0)
            index_col_name = df.columns[0]
            self.custom_matrix = df.set_index(index_col_name)
            self.custom_matrix.index = self.custom_matrix.index.astype(str)
            print(f"自定义组合矩阵形状: {self.custom_matrix.shape}")
        except Exception as e:
            print(f"加载自定义组合矩阵失败: {e}")
            self.custom_matrix = pd.DataFrame()

        # 3. 加载中证500指数数据 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.csi_data_file)
            df = pd.read_excel(file_path, sheet_name='中证500', header=0)
            df.rename(columns={'交易日期': 'Date', '收盘价': 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_returns = df['Close'].pct_change().dropna()
            print(f"中证500指数数据形状: {self.csi500_returns.shape} (按收盘价计算收益率)")
        except Exception as e:
            print(f"加载中证500指数数据失败: {e}")
            self.csi500_returns = pd.Series()

        # 4. 加载沪深300指数数据 (新增逻辑)
        try:
            file_path = os.path.join(self.data_path, self.hs300_data_file)
            # 假设沪深300数据只有两列：交易日期和收盘价 (如图片所示，不需指定Sheet名)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.hs300_returns = df['Close'].pct_change().dropna()
            print(f"沪深300指数数据形状: {self.hs300_returns.shape} (按收盘价计算收益率)")
        except Exception as e:
            print(f"加载沪深300指数数据失败: {e}")
            self.hs300_returns = pd.Series()

    # (get_custom_weights_by_date 方法不变)
    def get_custom_weights_by_date(self, rebalance_date):
        # ... (原有代码不变)
        if self.custom_matrix is None: return {}
        rebalance_date = pd.to_datetime(rebalance_date)
        col_dates = {pd.to_datetime(col, errors='coerce'): col for col in self.custom_matrix.columns}
        prev_adj_date = max([d for d in col_dates.keys() if not pd.isna(d) and d <= rebalance_date], default=None)
        if prev_adj_date:
            target_col_name = col_dates[prev_adj_date]
        else:
            return {}
        selected_stocks_raw = self.custom_matrix[self.custom_matrix[target_col_name] == 1].index.tolist()
        available_stocks = [
            s for s in selected_stocks_raw
            if s in self.price_data.columns
        ]
        if not available_stocks:
            return {}
        n = len(available_stocks)
        weight = 1.0 / n
        new_weights = {s: weight for s in available_stocks}
        return new_weights

    def run_backtest(self, start_date='2022-12-11', end_date='2025-07-30'):
        """执行回测并返回结果DataFrame，采用增量调仓逻辑，并计算沪深300净值。"""
        # 检查数据完整性，新增检查 hs300_returns
        if self.price_data.empty or self.custom_matrix.empty or self.csi500_returns.empty or self.hs300_returns.empty:
            print("数据不完整，无法进行回测。")
            return None

        # --- 确定回测周期和调仓日 ---
        rebalance_dates = [
            pd.to_datetime(col, errors='coerce')
            for col in self.custom_matrix.columns
            if pd.to_datetime(col, errors='coerce', dayfirst=False) is not pd.NaT
        ]
        rebalance_dates.sort()

        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        # 获取回测区间内的所有交易日 (使用所有基准和价格数据的交集)
        all_trading_dates = self.price_data.index.intersection(self.csi500_returns.index).intersection(
            self.hs300_returns.index)
        all_trading_dates = all_trading_dates[
            (all_trading_dates >= start_dt) &
            (all_trading_dates <= end_dt)
            ]

        if all_trading_dates.empty:
            print("回测区间内无交易日数据。")
            return None

        first_trading_date = all_trading_dates[0]
        future_rebalance_dates = [d for d in rebalance_dates if d > first_trading_date and d <= end_dt]

        # --- 初始化 ---
        strategy_name = '多因子策略'
        current_shares = {}
        cash = self.initial_capital
        cumulative_returns = pd.Series(index=all_trading_dates, dtype=float)
        csi500_value = self.initial_capital
        csi500_values = pd.Series(index=all_trading_dates, dtype=float)

        # 新增沪深300净值初始化
        hs300_value = self.initial_capital
        hs300_values = pd.Series(index=all_trading_dates, dtype=float)

        print(f"--- 回测开始，初始资金: {self.initial_capital / 10000:.0f} 万元 ---")

        # ... (初始建仓逻辑不变) ...
        # ==========================================================
        # --- 强制在第一个交易日进行初始化建仓 ---
        # ==========================================================
        initial_weights = self.get_custom_weights_by_date(first_trading_date)
        try:
            initial_prices = self.price_data.loc[first_trading_date].to_dict()
            can_initial_trade = True
        except KeyError:
            print(
                f"警告：第一个交易日 {first_trading_date.strftime('%Y-%m-%d')} 价格数据缺失，初始建仓失败。策略空仓开始。")
            can_initial_trade = False

        initial_buy_fee = 0
        if can_initial_trade and initial_weights:
            buy_value_total = 0
            new_shares_to_buy = {}
            current_portfolio_value = cash
            for stock, weight in initial_weights.items():
                price = initial_prices.get(stock, 0)
                if price > 0 and weight > 0:
                    target_value = current_portfolio_value * weight
                    target_shares = int((target_value / price) // 100) * 100
                    if target_shares > 0:
                        cost = target_shares * price
                        new_shares_to_buy[stock] = (target_shares, cost)
                        buy_value_total += cost
            if buy_value_total > 0 and buy_value_total <= cash:
                for stock, (shares, cost) in new_shares_to_buy.items():
                    fee = cost * self.buy_fee
                    initial_buy_fee += fee
                    current_shares[stock] = shares
                cash -= buy_value_total
                cash -= initial_buy_fee
                print(
                    f"**初始建仓日** {first_trading_date.strftime('%Y-%m-%d')} - 股票数: {len(current_shares)}, 费用: {initial_buy_fee:.2f}, 剩余现金: {cash:.2f}")

        # ==========================================================
        # --- 每日循环回测 ---
        # ==========================================================

        for i, date in enumerate(all_trading_dates):
            if i > 0:
                # 假设年化无风险利率为 1.5%，按 365 天计息
                daily_interest_rate = 0.015 / 365
                cash += cash * daily_interest_rate

            # --- 步骤 1：处理 i=0 的初始净值记录 ---
            if i == 0:
                cumulative_returns.loc[date] = self.initial_capital
                csi500_values.loc[date] = self.initial_capital
                hs300_values.loc[date] = self.initial_capital  # 沪深300初始值
                if len(current_shares) == 0:
                    portfolio_value = self.initial_capital
                else:
                    pass

            # --- 步骤 2：增量调仓逻辑 (逻辑不变) ---
            if date in future_rebalance_dates:
                sell_fee_total = 0
                buy_fee_total = 0
                try:
                    current_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    print(f"警告：调仓日 {date.strftime('%Y-%m-%d')} 价格数据缺失，跳过调仓。")
                    continue
                new_weights = self.get_custom_weights_by_date(date)
                current_market_value = sum(current_shares.get(stock, 0) * current_prices.get(stock, 0)
                                           for stock in current_shares.keys())
                current_portfolio_value = current_market_value + cash
                target_market_value = current_portfolio_value if new_weights else 0
                target_shares = {}
                stock_list_all = set(current_shares.keys()) | set(new_weights.keys())
                stock_diff = {}
                for stock in stock_list_all:
                    weight = new_weights.get(stock, 0)
                    price = current_prices.get(stock, 0)
                    current_s = current_shares.get(stock, 0)
                    if price > 0:
                        target_val = target_market_value * weight
                        target_s = int((target_val / price) // 100) * 100
                        diff = target_s - current_s
                        stock_diff[stock] = diff
                        target_shares[stock] = target_s
                sell_value_total = 0
                for stock, diff in stock_diff.items():
                    if diff < 0:
                        shares_to_sell = abs(diff)
                        price = current_prices.get(stock)
                        value = shares_to_sell * price
                        fee = value * self.sell_fee
                        sell_fee_total += fee
                        sell_value_total += value
                        current_shares[stock] = target_shares[stock]
                cash += (sell_value_total - sell_fee_total)
                buy_value_pending = 0
                buy_list = {}
                for stock, diff in stock_diff.items():
                    if diff > 0:
                        shares_to_buy = diff
                        price = current_prices.get(stock)
                        cost = shares_to_buy * price
                        buy_value_pending += cost
                        buy_list[stock] = (shares_to_buy, cost)
                if buy_value_pending > 0 and buy_value_pending <= cash:
                    for stock, (shares, cost) in buy_list.items():
                        fee = cost * self.buy_fee
                        buy_fee_total += fee
                        current_shares[stock] = target_shares[stock]
                    cash -= buy_value_pending
                    cash -= buy_fee_total
                    print(
                        f"调仓日 {date.strftime('%Y-%m-%d')} - 卖出费: {sell_fee_total:.2f}, 买入费: {buy_fee_total:.2f}, 调仓股票数: {len(current_shares)}, 剩余现金: {cash:.2f}")
                elif buy_value_pending > cash:
                    print(
                        f"警告：调仓日 {date.strftime('%Y-%m-%d')} 购买现金不足 ({buy_value_pending:.2f} > {cash:.2f})，放弃本次买入。")
                    for stock, diff in stock_diff.items():
                        if diff < 0:
                            pass

            # --- 步骤 3：每日净值更新 (新增沪深300更新) ---

            yesterday = all_trading_dates[i - 1] if i > 0 else date
            stock_market_value = 0

            if current_shares:
                portfolio_stocks = list(current_shares.keys())
                try:
                    today_prices = self.price_data.loc[date, portfolio_stocks].to_dict()
                except KeyError:
                    if i > 0:
                        portfolio_value = cumulative_returns.loc[yesterday]
                        cumulative_returns.loc[date] = portfolio_value
                        csi500_values.loc[date] = csi500_values.loc[yesterday]
                        hs300_values.loc[date] = hs300_values.loc[yesterday]  # 保持不变
                        continue
                    else:
                        portfolio_value = self.initial_capital

                for stock, shares in current_shares.items():
                    price = today_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0:
                        stock_market_value += shares * price

            portfolio_value = stock_market_value + cash

            # 基准净值更新
            daily_csi_return = self.csi500_returns.get(date, 0.0)
            daily_hs300_return = self.hs300_returns.get(date, 0.0)  # 新增沪深300收益率

            if i > 0:
                csi500_value *= (1 + daily_csi_return)
                hs300_value *= (1 + daily_hs300_return)  # 沪深300净值更新

            # --- 步骤 4：记录净值 ---
            if i > 0 or (i == 0 and len(current_shares) > 0):
                cumulative_returns.loc[date] = portfolio_value
                csi500_values.loc[date] = csi500_value
                hs300_values.loc[date] = hs300_value  # 记录沪深300净值

        # 将净值数据合并，并计算每日收益率
        cumulative_value_df = pd.DataFrame({
            strategy_name: cumulative_returns,
            'CSI500_Benchmark_Value': csi500_values,
            'HS300_Benchmark_Value': hs300_values  # 新增沪深300净值
        }).dropna()

        # 将累计价值转换为每日收益率 (用于指标计算)
        daily_returns_df = cumulative_value_df.pct_change().dropna()

        # 执行绩效指标计算
        self.calculate_metrics(daily_returns_df, cumulative_value_df)  # 传入累计净值用于最大涨幅/回撤

        # 季度收益率统计 (保持原有逻辑，只是数据源多了沪深300)
        quarterly_value_df = cumulative_value_df.resample('Q').ffill().dropna()
        quarterly_returns_df = quarterly_value_df.pct_change().dropna()

        quarterly_returns_df.rename(columns={
            strategy_name: f'{strategy_name}_季度收益率(%)',
            'CSI500_Benchmark_Value': 'CSI500_Benchmark_季度收益率(%)',
            'HS300_Benchmark_Value': 'HS300_Benchmark_季度收益率(%)'  # 新增沪深300季度收益
        }, inplace=True)

        quarterly_returns_df *= 100  # 转换为百分比
        print("\n--- 季度收益率统计 ---")
        print(quarterly_returns_df)

        # 最终返回累计收益率百分比
        results_df = pd.DataFrame({
            strategy_name: (cumulative_returns / self.initial_capital - 1) * 100,
            'CSI500_Benchmark': (csi500_values / self.initial_capital - 1) * 100,
            'HS300_Benchmark': (hs300_values / self.initial_capital - 1) * 100  # 新增沪深300累计收益
        })

        return results_df.dropna()

    def calculate_metrics(self, daily_returns_df, cumulative_value_df):
        """
        【修改】计算雷达图所需指标，并将结果存储在 self.metrics_results 中。
        基准以中证500 (CSI500) 为主（相对基准胜率、信息比率）。
        """
        if daily_returns_df.empty or cumulative_value_df.empty:
            print("每日收益率或累计净值数据为空，无法计算绩效指标。")
            return

        # 假设无风险日收益率 (R_f)
        risk_free_rate_daily = 0.015 / 250
        trading_days_per_year = 250

        strategy_col = '多因子策略'
        csi_col_daily = 'CSI500_Benchmark_Value'  # 用于每日收益率DF

        # --- 基本计算 ---
        total_days = len(daily_returns_df)
        total_return_strategy = (1 + daily_returns_df[strategy_col]).prod() - 1

        annualized_return_strategy = (1 + total_return_strategy) ** (trading_days_per_year / total_days) - 1
        annualized_volatility_strategy = daily_returns_df[strategy_col].std() * np.sqrt(trading_days_per_year)

        # 累计净值序列 (用于最大回撤和最大涨幅)
        cumulative_wealth = cumulative_value_df[strategy_col] / self.initial_capital

        # --- 1. 最大回撤 (Maximum Drawdown) ---
        peak = cumulative_wealth.expanding(min_periods=1).max()
        drawdown = (cumulative_wealth / peak) - 1
        max_drawdown = drawdown.min()  # 这是一个负值

        # --- 2. 区间最大涨幅 (Max Gain over Period) ---
        # 简单定义为净值的 (最大值 / 最小值) - 1，或者更严谨地，任意两点间的最大累计收益
        # 这里采用净值的 (最大值 / 初始值) - 1 来近似，或者直接使用总收益
        # 更严谨的计算 (任意两点最大涨幅)：
        min_wealth = cumulative_wealth.expanding(min_periods=1).min()
        max_gain_series = cumulative_wealth / min_wealth - 1
        max_gain_period = max_gain_series.max()

        # --- 3. 夏普比率 (Sharpe Ratio) ---
        # 使用年化数据
        sharpe_ratio = (annualized_return_strategy - (
                risk_free_rate_daily * trading_days_per_year)) / annualized_volatility_strategy

        # --- 4. Calmar比率 (Calmar Ratio) ---
        # Calmar = 年化收益 / |最大回撤|
        calmar_ratio = annualized_return_strategy / abs(max_drawdown) if abs(max_drawdown) > 0 else np.nan

        # --- 5. 跟踪误差和信息比率 (基准: CSI500) ---
        tracking_difference = daily_returns_df[strategy_col] - daily_returns_df[csi_col_daily]
        tracking_error = tracking_difference.std() * np.sqrt(trading_days_per_year)

        csi_annual_return = (1 + (daily_returns_df[csi_col_daily]).prod()) ** (trading_days_per_year / total_days) - 1
        annual_excess_vs_csi = annualized_return_strategy - csi_annual_return
        information_ratio = annual_excess_vs_csi / tracking_error if tracking_error != 0 else np.nan

        # --- 6. 相对基准胜率 (基准: CSI500) ---
        win_days = (daily_returns_df[strategy_col] > daily_returns_df[csi_col_daily]).sum()
        relative_win_rate = win_days / total_days

        # --- 存储结果 ---
        self.metrics_results = {
            '年化收益率': annualized_return_strategy,
            '年化波动率': annualized_volatility_strategy,
            '区间最大涨幅': max_gain_period,
            '区间最大回撤': abs(max_drawdown),  # 雷达图通常用正值表示回撤的幅度
            '夏普比率': sharpe_ratio,
            'Calmar比率': calmar_ratio,
            '信息比率': information_ratio,
            '相对基准胜率': relative_win_rate
        }

        # --- 打印结果 (保持原有打印格式) ---
        print("\n" + "=" * 50)
        print("======== 策略绩效指标 (雷达图八项指标) ========")
        print("=" * 50)
        for name, value in self.metrics_results.items():
            if name in ['年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤']:
                print(f"{name}: {value * 100:.2f}%")
            elif name == '相对基准胜率':
                print(f"{name}: {value * 100:.2f}%")
            else:
                print(f"{name}: {value:.2f}")
        print("=" * 50)

    def plot_radar(self, benchmark_metrics=None, radar_max_val=1.0):
        """
        绘制策略相对于某一基准/同类平均的雷达图。
        由于缺乏同类产品数据，此处只绘制策略本身的指标，并使用最大值归一化。
        """
        if not self.metrics_results:
            print("指标数据为空，无法绘制雷达图。请先运行 calculate_metrics。")
            return

        # 确保指标顺序与图片一致 (从上方的"年化收益率"开始，顺时针)
        metrics_order = [
            '年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤',
            'Calmar比率', '信息比率', '相对基准胜率', '夏普比率'  # 夏普比率排在最后以匹配图示
        ]

        # 获取指标值
        values = [self.metrics_results.get(m, 0) for m in metrics_order]

        # 特别处理：波动率、最大回撤是负向指标，需要反转。
        # 这里用最大值归一化，且假设所有指标都越大越好 (除了雷达图中的显示)
        # 实际绘制时，我们只关心其相对大小。

        # 将指标名转为中文，以便绘图
        labels = ['年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤',
                  '夏普比率', 'Calmar比率', '信息比率', '相对基准胜率']
        # 调整顺序以匹配图片 (图片是 8 个，从上顺时针)
        # 年化收益率 -> 年化波动率 -> 区间最大涨幅 -> 区间最大回撤 -> 夏普比率 -> Calmar比率 -> 信息比率 -> 相对基准胜率
        # (Calmar和夏普位置与图片不完全一致，但雷达图绘制需要特定顺序)

        # 重新排序以匹配图片：
        # 1. 年化收益率 (正)
        # 2. 年化波动率 (负)
        # 3. 区间最大涨幅 (正)
        # 4. 区间最大回撤 (负)
        # 5. 夏普比率 (正)
        # 6. Calmar比率 (正)
        # 7. 信息比率 (正)
        # 8. 相对基准胜率 (正)

        # 修正顺序和标签以匹配图示（顺时针）：
        labels = [
            '年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤',
            '夏普比率', 'Calmar比率', '信息比率', '相对基准胜率'
        ]

        # 提取并确保顺序：
        values_raw = [
            self.metrics_results['年化收益率'],
            self.metrics_results['年化波动率'],
            self.metrics_results['区间最大涨幅'],
            self.metrics_results['区间最大回撤'],  # 最大回撤是正值(幅度)
            self.metrics_results['Calmar比率'],
            self.metrics_results['信息比率'],
            self.metrics_results['相对基准胜率'],
            self.metrics_results['夏普比率']
        ]

        # 归一化处理：将所有指标归一化到 [0, radar_max_val] 范围
        # 步骤 1: 将所有指标转换为正值（波动率和最大回撤已经确保是正值幅度）
        # 步骤 2: 找到最大值 (Max_All)
        # 步骤 3: 归一化 (Value / Max_All * radar_max_val)

        # 这里使用一个简化的归一化，假设所有值都在 0 到 1 之间（像图示那样）
        # 对于实际的指数增强基金报告，这个刻度通常是相对同类产品的表现分（0-1）
        # 由于我们没有同类数据，我们假设一个归一化因子来使图看起来合理。

        # 简化处理：手动设置一个最大值（例如，年化收益率 50%，波动率 30%，比率 2.0，胜率 70%）
        # 再次检查图示刻度：0.0 到 1.0

        # 假设：
        # 1. 年化收益率：最大 100% -> 1.0
        # 2. 年化波动率：最大 50% -> 1.0 (反向指标，越低越好，但图中是越大越好)
        # 3. 最大涨幅：最大 100% -> 1.0
        # 4. 最大回撤：最大 50% -> 1.0 (反向指标，越低越好，但图中是越大越好)
        # 5. 比率类：最大 2.0 -> 1.0
        # 6. 胜率：最大 100% -> 1.0

        # 为了生成一个看起来像图示的雷达图，我们使用图示的刻度范围 (0.0 到 1.0)
        # 假设这些指标是相对**同类产品平均值**的归一化得分。

        # 示例归一化因子 (这些值是**假设**的，用于将策略值映射到 0-1 的雷达图刻度)
        max_factors = [
            0.50,  # 年化收益率 (50%)
            0.30,  # 年化波动率 (30%)
            0.2,  # 区间最大涨幅 (100%)
            0.30,  # 区间最大回撤 (30%幅度)
            1,  # Calmar比率
            1,  # 信息比率
            0.70,  # 相对基准胜率 (70%)
            0.5  # 夏普比率
        ]

        # 归一化值：
        normalized_values = []
        for raw_val, max_factor in zip(values_raw, max_factors):
            # 将策略值除以归一化因子，限制在 [0, 1] 之间
            norm_val = raw_val / max_factor if max_factor != 0 else 0
            # 波动率和最大回撤是负向指标，但图上的点在外圈说明表现好。
            # 在没有同类对比数据的情况下，我们假设雷达图的点越靠近外圈越好，
            # 意味着策略在这两个指标上相对于同类平均表现优秀 (即波动小/回撤小)。
            # 由于我们只画策略，简单取 norm_val，让绘图看起来像图示。

            # 为了使图表看起来合理，我们对波动率和回撤进行**反向归一化**（如果它们是负向指标）：
            # 反转逻辑：1 - (Vol / Max_Vol_Benchmark)
            if labels[len(normalized_values)] in ['年化波动率', '区间最大回撤']:
                # 在没有基准的情况下，暂时不反转，只作归一化。
                normalized_values.append(np.clip(norm_val, 0, 1.0))
            else:
                normalized_values.append(np.clip(norm_val, 0, 1.0))

        # 雷达图需要闭合，因此在数据末尾添加第一个数据点
        values_plot = normalized_values + [normalized_values[0]]

        # 计算角度
        angles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False).tolist()
        angles += angles[:1]

        fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

        # 绘制策略线
        ax.plot(angles, values_plot, linewidth=2, linestyle='solid', color='tab:blue', label='农一中证500指数增强基金')
        ax.fill(angles, values_plot, color='tab:blue', alpha=0.1)

        # 设置标签
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, fontsize=12)

        # 设置刻度 (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)
        ax.set_yticks(np.arange(0, radar_max_val + 0.2, 0.2))
        ax.set_yticklabels([f'{val:.1f}' for val in np.arange(0, radar_max_val + 0.2, 0.2)], color="gray", size=10)
        ax.set_ylim(0, radar_max_val)

        # 调整刻度标签位置
        ax.tick_params(pad=17)

        plt.title('农一中证500指数增强基金绩效雷达图 (归一化)', size=14, y=1.1)
        plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
        plt.show()


# (plot_performance 函数保持不变)
def plot_performance(results_df):
    """绘制投资组合累积收益率图表，新增沪深300。"""
    if results_df is None or results_df.empty:
        print("没有可用于绘制的投资组合回测结果。")
        return

    plt.figure(figsize=(12, 7))

    # 策略颜色和标签映射，新增沪深300
    strategy_config = {
        '多因子策略': {'color': 'brown', 'label': '多因子策略', 'linestyle': '-', 'linewidth': 2},
        'CSI500_Benchmark': {'color': 'black', 'label': '中证500指数 (基准1)', 'linestyle': '--', 'linewidth': 2,
                             'alpha': 0.7},
        'HS300_Benchmark': {'color': 'green', 'label': '沪深300指数 (基准2)', 'linestyle': ':', 'linewidth': 2,
                            'alpha': 0.7}  # 新增
    }

    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            data = results_df[strategy]
            plt.plot(data.index, data.values,
                     color=config['color'],
                     label=config['label'],
                     linestyle=config['linestyle'],
                     linewidth=config['linewidth'],
                     alpha=config.get('alpha', 1))

    # 设置图表样式
    try:
        title_capital = f"初始资金 {tester.initial_capital / 10000:.0f} 万元"
    except NameError:
        title_capital = "初始资金 100 万元"

    plt.title(f'多因子策略 vs. 基准指数 ({title_capital})', fontsize=14, fontweight='bold', pad=15)
    plt.xlabel('日期', fontsize=10)
    plt.ylabel('累积收益率 (%)', fontsize=10)
    plt.legend(fontsize=10, loc='best')
    plt.grid(False)

    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
    plt.gcf().autofmt_xdate()
    plt.axhline(y=0, color='red', linestyle='-', alpha=0.5, linewidth=1)
    plt.tight_layout()
    plt.show()

    print("\n各策略最终累积收益率统计：")
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            final_return = results_df[strategy].iloc[-1]
            print(f"{config['label']}: {final_return:.2f}%")


if __name__ == "__main__":
    # !!! 请根据您的实际文件路径和文件名进行修改 !!!
    data_path = r"C:\Users\cufet\Desktop\测试集"

    STOCK_DATA_FILE = "优化权重结果.xlsx"
    CSI500_INDEX_FILE = "中证500指数日收益率.xls"
    # 新增沪深300数据文件名称 (假设您将其命名为这个)
    HS300_INDEX_FILE = "沪深300指数收盘价.xls"

    try:
        # 实例化类，新增沪深300文件路径
        tester = SimplePortfolioBacktester(data_path, STOCK_DATA_FILE, CSI500_INDEX_FILE, HS300_INDEX_FILE)

        if not tester.price_data.empty and not tester.custom_matrix.empty and not tester.csi500_returns.empty and not tester.hs300_returns.empty:
            print("--- 开始回测 ---")
            portfolio_results_df = tester.run_backtest(
                start_date='2022-12-13',
                end_date='2025-09-1'
            )

            if portfolio_results_df is not None:
                print("--- 结果可视化 ---")
                plot_performance(portfolio_results_df)

                # 【新增】绘制雷达图
                print("--- 雷达图绘制 ---")
                tester.plot_radar(radar_max_val=1.0)  # 设置最大刻度为 1.0

    except Exception as e:
        print(f"分析过程中出现错误: {e}")
