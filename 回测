import pandas as pd
import numpy as np
import os
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

import pandas as pd
import numpy as np
import os
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
# 使用 TkAgg 后端确保绘图正常显示
# 注意：在某些环境中 (例如没有图形界面的服务器或在线Notebook)，
# 'TkAgg'可能不起作用，您可能需要改为 'Agg' 或删除此行，
# 但对于本地测试，'TkAgg'是常用选择。
# 已经在原代码中设置：matplotlib.use('TkAgg')


import matplotlib.dates as mdates
import warnings
from datetime import timedelta

# --- 辅助设置 ---
warnings.filterwarnings('ignore')
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


class SimplePortfolioBacktester:
    # 增加 hs300_data_file 参数
    def __init__(self, data_path, stock_data_file, csi_data_file, hs300_data_file):
        self.data_path = data_path
        self.stock_data_file = stock_data_file
        self.csi_data_file = csi_data_file
        self.hs300_data_file = hs300_data_file  # 新增沪深300文件

        self.price_data = None
        self.custom_matrix = None
        self.csi500_returns = None
        self.hs300_returns = None  # 沪深300收益率

        # 新增：存储计算的指标结果
        self.metrics_results = {}

        # 【修改 1-1：新增属性】 收集每日持仓数据
        self.daily_holdings_history = []

        # 交易成本设置
        self.initial_capital = 10000000  # 初始资金10亿
        self.buy_fee = 0.0003  # 买入费率 0.03% (万3)
        self.sell_fee = 0.0013  # 卖出费率 0.05% (万5)

        self._load_all_data()

    def _load_all_data(self):
        # ... (此方法保持不变) ...
        """加载所有数据：股票价格、自定义组合矩阵、中证500指数、沪深300指数。"""

        # 1. 加载股票收盘价 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='全部数据', header=0)
            df = df.iloc[1:].set_index(df.columns[0])
            df.index = pd.to_datetime(df.index)
            df.columns = df.columns.astype(str)
            self.price_data = df.apply(pd.to_numeric, errors='coerce').ffill()
            print(f"股票价格数据形状: {self.price_data.shape}")
        except Exception as e:
            print(f"加载股票价格数据失败: {e}")
            self.price_data = pd.DataFrame()

        # 2. 加载自定义组合状态矩阵 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.stock_data_file)
            df = pd.read_excel(file_path, sheet_name='Sheet2', header=0)
            index_col_name = df.columns[0]
            self.custom_matrix = df.set_index(index_col_name)
            self.custom_matrix.index = self.custom_matrix.index.astype(str)
            print(f"自定义组合矩阵形状: {self.custom_matrix.shape}")
        except Exception as e:
            print(f"加载自定义组合矩阵失败: {e}")
            self.custom_matrix = pd.DataFrame()

        # 3. 加载中证500指数数据 (原有逻辑不变)
        try:
            file_path = os.path.join(self.data_path, self.csi_data_file)
            df = pd.read_excel(file_path, sheet_name='中证500', header=0)
            df.rename(columns={'交易日期': 'Date', '收盘价': 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.csi500_returns = df['Close'].pct_change().dropna()
            print(f"中证500指数数据形状: {self.csi500_returns.shape} (按收盘价计算收益率)")
        except Exception as e:
            print(f"加载中证500指数数据失败: {e}")
            self.csi500_returns = pd.Series()

        # 4. 加载沪深300指数数据 (新增逻辑)
        try:
            file_path = os.path.join(self.data_path, self.hs300_data_file)
            # 假设沪深300数据只有两列：交易日期和收盘价 (如图片所示，不需指定Sheet名)
            df = pd.read_excel(file_path, header=0)
            df.rename(columns={df.columns[0]: 'Date', df.columns[1]: 'Close'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            df['Close'] = pd.to_numeric(df['Close'], errors='coerce')
            df = df.sort_index().dropna(subset=['Close'])
            self.hs300_returns = df['Close'].pct_change().dropna()
            print(f"沪深300指数数据形状: {self.hs300_returns.shape} (按收盘价计算收益率)")
        except Exception as e:
            print(f"加载沪深300指数数据失败: {e}")
            self.hs300_returns = pd.Series()

    # (get_custom_weights_by_date 方法不变)
    def get_custom_weights_by_date(self, rebalance_date):
        # ... (原有代码不变)
        if self.custom_matrix is None: return {}
        rebalance_date = pd.to_datetime(rebalance_date)
        col_dates = {pd.to_datetime(col, errors='coerce'): col for col in self.custom_matrix.columns}
        prev_adj_date = max([d for d in col_dates.keys() if not pd.isna(d) and d <= rebalance_date], default=None)
        if prev_adj_date:
            target_col_name = col_dates[prev_adj_date]
        else:
            return {}
        selected_stocks_raw = self.custom_matrix[self.custom_matrix[target_col_name] == 1].index.tolist()
        available_stocks = [
            s for s in selected_stocks_raw
            if s in self.price_data.columns
        ]
        if not available_stocks:
            return {}
        n = len(available_stocks)
        weight = 1.0 / n
        new_weights = {s: weight for s in available_stocks}
        return new_weights

    def run_backtest(self, start_date='2022-12-11', end_date='2025-07-30'):
        """执行回测并返回结果DataFrame，采用增量调仓逻辑，并计算沪深300净值。"""
        # 检查数据完整性，新增检查 hs300_returns
        if self.price_data.empty or self.custom_matrix.empty or self.csi500_returns.empty or self.hs300_returns.empty:
            print("数据不完整，无法进行回测。")
            return None

        # --- 确定回测周期和调仓日 ---
        rebalance_dates = [
            pd.to_datetime(col, errors='coerce')
            for col in self.custom_matrix.columns
            if pd.to_datetime(col, errors='coerce', dayfirst=False) is not pd.NaT
        ]
        rebalance_dates.sort()

        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        # 获取回测区间内的所有交易日 (使用所有基准和价格数据的交集)
        all_trading_dates = self.price_data.index.intersection(self.csi500_returns.index).intersection(
            self.hs300_returns.index)
        all_trading_dates = all_trading_dates[
            (all_trading_dates >= start_dt) &
            (all_trading_dates <= end_dt)
            ]

        if all_trading_dates.empty:
            print("回测区间内无交易日数据。")
            return None

        first_trading_date = all_trading_dates[0]
        future_rebalance_dates = [d for d in rebalance_dates if d > first_trading_date and d <= end_dt]

        # --- 初始化 ---
        strategy_name = '多因子策略'
        current_shares = {}
        cash = self.initial_capital
        cumulative_returns = pd.Series(index=all_trading_dates, dtype=float)
        csi500_value = self.initial_capital
        csi500_values = pd.Series(index=all_trading_dates, dtype=float)

        # 新增沪深300净值初始化
        hs300_value = self.initial_capital
        hs300_values = pd.Series(index=all_trading_dates, dtype=float)

        # 【修改 1-2：清空历史记录】确保每次回测都从空列表开始
        self.daily_holdings_history = []

        print(f"--- 回测开始，初始资金: {self.initial_capital / 10000:.0f} 万元 ---")

        # ... (初始建仓逻辑不变) ...
        # ==========================================================
        # --- 强制在第一个交易日进行初始化建仓 ---
        # ==========================================================
        initial_weights = self.get_custom_weights_by_date(first_trading_date)
        try:
            initial_prices = self.price_data.loc[first_trading_date].to_dict()
            can_initial_trade = True
        except KeyError:
            print(
                f"警告：第一个交易日 {first_trading_date.strftime('%Y-%m-%d')} 价格数据缺失，初始建仓失败。策略空仓开始。")
            can_initial_trade = False

        initial_buy_fee = 0
        if can_initial_trade and initial_weights:
            buy_value_total = 0
            new_shares_to_buy = {}
            current_portfolio_value = cash
            for stock, weight in initial_weights.items():
                price = initial_prices.get(stock, 0)
                if price > 0 and weight > 0:
                    target_value = current_portfolio_value * weight
                    target_shares = int((target_value / price) // 100) * 100
                    if target_shares > 0:
                        cost = target_shares * price
                        new_shares_to_buy[stock] = (target_shares, cost)
                        buy_value_total += cost
            if buy_value_total > 0 and buy_value_total <= cash:
                for stock, (shares, cost) in new_shares_to_buy.items():
                    fee = cost * self.buy_fee
                    initial_buy_fee += fee
                    current_shares[stock] = shares
                cash -= buy_value_total
                cash -= initial_buy_fee
                print(
                    f"**初始建仓日** {first_trading_date.strftime('%Y-%m-%d')} - 股票数: {len(current_shares)}, 费用: {initial_buy_fee:.2f}, 剩余现金: {cash:.2f}")

        # ==========================================================
        # --- 每日循环回测 ---
        # ==========================================================

        # 记录前一日的持仓（用作今日期初）
        prev_shares = {}

        for i, date in enumerate(all_trading_dates):

            # 【修改 2-1：记录期初持仓】
            # 当日调仓发生在日终，所以**当日开盘（期初）**持仓量是前一交易日的期末持仓量（即昨日的 `current_shares`）
            # 注意：在第一天 i=0 时，prev_shares 即为初始建仓后的持仓。
            initial_holdings_data = []
            if i > 0:
                try:
                    open_prices = self.price_data.loc[date].to_dict()  # 用当日收盘价近似期初价格（简化处理）
                except KeyError:
                    open_prices = {}

                # 记录期初持仓 (前一日的期末持仓)
                for stock, shares in prev_shares.items():
                    price = open_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0:
                        initial_holdings_data.append({
                            '日期': date,
                            '股票代码': stock,
                            '持仓类型': '期初',
                            '持仓股数': shares,
                            '收盘价': price,
                            '持仓市值': shares * price
                        })

            if i > 0:
                # 假设年化无风险利率为 1.5%，按 365 天计息
                daily_interest_rate = 0.015 / 365
                cash += cash * daily_interest_rate

            # --- 步骤 1：处理 i=0 的初始净值记录 ---
            if i == 0:
                cumulative_returns.loc[date] = self.initial_capital
                csi500_values.loc[date] = self.initial_capital
                hs300_values.loc[date] = self.initial_capital  # 沪深300初始值
                if len(current_shares) == 0:
                    portfolio_value = self.initial_capital
                else:
                    # 初始建仓日的期末持仓就是 current_shares
                    pass

            # 【修改 2-2：在 i=0 时记录期初持仓（即初始建仓后的持仓）】
            if i == 0 and len(current_shares) > 0:
                try:
                    initial_prices_at_close = self.price_data.loc[date].to_dict()
                except KeyError:
                    initial_prices_at_close = {}

                for stock, shares in current_shares.items():
                    price = initial_prices_at_close.get(stock, np.nan)
                    if not pd.isna(price) and price > 0 and shares > 0:
                        initial_holdings_data.append({
                            '日期': date,
                            '股票代码': stock,
                            '持仓类型': '期初',
                            '持仓股数': shares,
                            '收盘价': price,
                            '持仓市值': shares * price
                        })

            # 记录期初数据（如果是 i>0 的日期，这里已包含前一日的期末持仓；如果是 i=0 且有建仓，这里是初始持仓）
            self.daily_holdings_history.extend(initial_holdings_data)

            # --- 步骤 2：增量调仓逻辑 (逻辑不变) ---
            if date in future_rebalance_dates:
                # ... (调仓逻辑不变) ...
                sell_fee_total = 0
                buy_fee_total = 0
                try:
                    current_prices = self.price_data.loc[date].to_dict()
                except KeyError:
                    print(f"警告：调仓日 {date.strftime('%Y-%m-%d')} 价格数据缺失，跳过调仓。")
                    # 在跳过调仓时，需要确保 prev_shares 在下一轮循环中仍是正确的
                    prev_shares = current_shares.copy()
                    continue
                new_weights = self.get_custom_weights_by_date(date)
                current_market_value = sum(current_shares.get(stock, 0) * current_prices.get(stock, 0)
                                           for stock in current_shares.keys())
                current_portfolio_value = current_market_value + cash
                target_market_value = current_portfolio_value if new_weights else 0
                target_shares = {}
                stock_list_all = set(current_shares.keys()) | set(new_weights.keys())
                stock_diff = {}
                for stock in stock_list_all:
                    weight = new_weights.get(stock, 0)
                    price = current_prices.get(stock, 0)
                    current_s = current_shares.get(stock, 0)
                    if price > 0:
                        target_val = target_market_value * weight
                        target_s = int((target_val / price) // 100) * 100
                        diff = target_s - current_s
                        stock_diff[stock] = diff
                        target_shares[stock] = target_s
                sell_value_total = 0
                for stock, diff in stock_diff.items():
                    if diff < 0:
                        shares_to_sell = abs(diff)
                        price = current_prices.get(stock)
                        value = shares_to_sell * price
                        fee = value * self.sell_fee
                        sell_fee_total += fee
                        sell_value_total += value
                        current_shares[stock] = target_shares[stock]
                cash += (sell_value_total - sell_fee_total)
                buy_value_pending = 0
                buy_list = {}
                for stock, diff in stock_diff.items():
                    if diff > 0:
                        shares_to_buy = diff
                        price = current_prices.get(stock)
                        cost = shares_to_buy * price
                        buy_value_pending += cost
                        buy_list[stock] = (shares_to_buy, cost)
                if buy_value_pending > 0 and buy_value_pending <= cash:
                    for stock, (shares, cost) in buy_list.items():
                        fee = cost * self.buy_fee
                        buy_fee_total += fee
                        current_shares[stock] = target_shares[stock]
                    cash -= buy_value_pending
                    cash -= buy_fee_total
                    print(
                        f"调仓日 {date.strftime('%Y-%m-%d')} - 卖出费: {sell_fee_total:.2f}, 买入费: {buy_fee_total:.2f}, 调仓股票数: {len(current_shares)}, 剩余现金: {cash:.2f}")
                elif buy_value_pending > cash:
                    print(
                        f"警告：调仓日 {date.strftime('%Y-%m-%d')} 购买现金不足 ({buy_value_pending:.2f} > {cash:.2f})，放弃本次买入。")
                    for stock, diff in stock_diff.items():
                        if diff < 0:
                            pass

            # --- 步骤 3：每日净值更新 (新增沪深300更新) ---

            yesterday = all_trading_dates[i - 1] if i > 0 else date
            stock_market_value = 0

            end_holdings_data = []  # 【修改 2-3：新增期末持仓数据列表】

            if current_shares:
                portfolio_stocks = list(current_shares.keys())
                try:
                    today_prices = self.price_data.loc[date, portfolio_stocks].to_dict()
                except KeyError:
                    if i > 0:
                        portfolio_value = cumulative_returns.loc[yesterday]
                        cumulative_returns.loc[date] = portfolio_value
                        csi500_values.loc[date] = csi500_values.loc[yesterday]
                        hs300_values.loc[date] = hs300_values.loc[yesterday]  # 保持不变

                        # 价格缺失时，期末持仓仍等于期初，但市值使用前一天的价格（跳过记录期末）
                        prev_shares = current_shares.copy()
                        continue
                    else:
                        portfolio_value = self.initial_capital

                for stock, shares in current_shares.items():
                    price = today_prices.get(stock, np.nan)
                    if not pd.isna(price) and price > 0:
                        stock_market_value += shares * price

                        # 【修改 2-4：记录期末持仓数据】
                        end_holdings_data.append({
                            '日期': date,
                            '股票代码': stock,
                            '持仓类型': '期末',
                            '持仓股数': shares,
                            '收盘价': price,
                            '持仓市值': shares * price
                        })
                if date in future_rebalance_dates:
                    new_weights = self.get_custom_weights_by_date(date)
                    # 过滤掉权重为0的股票的期末持仓记录
                    end_holdings_data = [holding for holding in end_holdings_data
                                         if new_weights.get(holding['股票代码'], 0) > 0]

            portfolio_value = stock_market_value + cash

            # 基准净值更新
            daily_csi_return = self.csi500_returns.get(date, 0.0)
            daily_hs300_return = self.hs300_returns.get(date, 0.0)  # 新增沪深300收益率

            if i > 0:
                csi500_value *= (1 + daily_csi_return)
                hs300_value *= (1 + daily_hs300_return)  # 沪深300净值更新

            # --- 步骤 4：记录净值 ---
            if i > 0 or (i == 0 and len(current_shares) > 0):
                cumulative_returns.loc[date] = portfolio_value
                csi500_values.loc[date] = csi500_value
                hs300_values.loc[date] = hs300_value  # 记录沪深300净值

            # 【修改 2-5：记录期末持仓数据】
            self.daily_holdings_history.extend(end_holdings_data)

            # 【修改 2-6：更新 prev_shares】 记录当前的持仓量，用作下一轮循环的期初持仓量
            prev_shares = current_shares.copy()

        # 将净值数据合并，并计算每日收益率
        cumulative_value_df = pd.DataFrame({
            strategy_name: cumulative_returns,
            'CSI500_Benchmark_Value': csi500_values,
            'HS300_Benchmark_Value': hs300_values  # 新增沪深300净值
        }).dropna()

        # 将累计价值转换为每日收益率 (用于指标计算)
        daily_returns_df = cumulative_value_df.pct_change().dropna()

        # 执行绩效指标计算
        self.calculate_metrics(daily_returns_df, cumulative_value_df)  # 传入累计净值用于最大涨幅/回撤

        # 季度收益率统计 (保持原有逻辑，只是数据源多了沪深300)
        quarterly_value_df = cumulative_value_df.resample('Q').ffill().dropna()
        quarterly_returns_df = quarterly_value_df.pct_change().dropna()

        quarterly_returns_df.rename(columns={
            strategy_name: f'{strategy_name}_季度收益率(%)',
            'CSI500_Benchmark_Value': 'CSI500_Benchmark_季度收益率(%)',
            'HS300_Benchmark_Value': 'HS300_Benchmark_季度收益率(%)'  # 新增沪深300季度收益
        }, inplace=True)

        quarterly_returns_df *= 100  # 转换为百分比
        print("\n--- 季度收益率统计 ---")
        print(quarterly_returns_df)

        # 最终返回累计收益率百分比
        results_df = pd.DataFrame({
            strategy_name: (cumulative_returns / self.initial_capital - 1) * 100,
            'CSI500_Benchmark': (csi500_values / self.initial_capital - 1) * 100,
            'HS300_Benchmark': (hs300_values / self.initial_capital - 1) * 100  # 新增沪深300累计收益
        })

        return results_df.dropna()


    def _output_holdings_to_excel(self, output_file_name="个股持仓市值详情.xlsx"):
        """将收集到的每日持仓市值数据导出到 Excel，按调仓日分sheet，宽数据格式"""
        if not self.daily_holdings_history:
            print("持仓历史数据为空，不进行导出。")
            return

        df = pd.DataFrame(self.daily_holdings_history)
        df['日期'] = pd.to_datetime(df['日期'])

        # 只保留期末持仓数据
        df = df[df['持仓类型'] == '期末']

        # 获取调仓日列表
        rebalance_dates = [
            pd.to_datetime(col, errors='coerce')
            for col in self.custom_matrix.columns
            if pd.to_datetime(col, errors='coerce', dayfirst=False) is not pd.NaT
        ]
        rebalance_dates.sort()

        output_path = os.path.join(self.data_path, output_file_name)

    # 【修改位置】：在 _output_holdings_to_excel 方法中修改第一个调仓周期的逻辑
        try:
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                # 为每个调仓周期创建一个sheet
                for i in range(len(rebalance_dates)):
                    if i == 0:
                        # 【修改】：第一个调仓周期：从数据开始日期到第一个调仓日（包含调仓日）
                        start_date = df['日期'].min()
                        end_date = rebalance_dates[i]
                        # 【关键修改】：确保end_date不早于start_date，并且使用实际数据中的日期范围
                        if end_date < start_date:
                            # 如果调仓日早于数据开始日期，调整到数据开始日期
                            end_date = start_date
                        period_df = df[(df['日期'] >= start_date) & (df['日期'] <= end_date)]
                        sheet_name = f"周期1_{end_date.strftime('%Y%m%d')}"
                    else:
                        # 中间调仓周期：从前一个调仓日后到当前调仓日
                        start_date = rebalance_dates[i - 1] + timedelta(days=1)
                        end_date = rebalance_dates[i]
                        period_df = df[(df['日期'] >= start_date) & (df['日期'] <= end_date)]
                        sheet_name = f"周期{i + 1}_{end_date.strftime('%Y%m%d')}"

                    # 【新增】：如果period_df为空，跳过创建该sheet
                    if period_df.empty:
                        print(f"跳过空sheet: {sheet_name} (无数据)")
                        continue

                    # 转换为宽数据格式：横轴为日期，纵轴为股票代码
                    pivot_df = period_df.pivot_table(
                        index='股票代码',
                        columns='日期',
                        values='持仓市值',
                        aggfunc='first'
                    ).fillna(0)

                    # 写入sheet
                    pivot_df.to_excel(writer, sheet_name=sheet_name)
                    print(f"创建sheet: {sheet_name}, 数据形状: {pivot_df.shape}")

                # 最后一个调仓周期之后的数据
                if rebalance_dates:
                    last_rebalance = rebalance_dates[-1]
                    last_period_df = df[df['日期'] > last_rebalance]
                    if not last_period_df.empty:
                        sheet_name = f"最后周期_{df['日期'].max().strftime('%Y%m%d')}"
                        pivot_df = last_period_df.pivot_table(
                            index='股票代码',
                            columns='日期',
                            values='持仓市值',
                            aggfunc='first'
                        ).fillna(0)
                        pivot_df.to_excel(writer, sheet_name=sheet_name)
                        print(f"创建sheet: {sheet_name}, 数据形状: {pivot_df.shape}")

                # 【新增】：如果所有周期都为空，创建一个总览sheet
                if len(writer.sheets) == 0:
                    # 直接使用所有数据创建一个sheet
                    pivot_df = df.pivot_table(
                        index='股票代码',
                        columns='日期',
                        values='持仓市值',
                        aggfunc='first'
                    ).fillna(0)
                    pivot_df.to_excel(writer, sheet_name="总览")
                    print(f"创建总览sheet, 数据形状: {pivot_df.shape}")

            print(f"\n成功导出个股持仓市值详情至: {output_path}")
            print("格式：按调仓周期分sheet，宽数据格式（股票代码为行，日期为列）")

        except Exception as e:
            print(f"\n导出个股持仓市值详情失败: {e}")

    def calculate_metrics(self, daily_returns_df, cumulative_value_df):
        # ... (此方法保持不变) ...
        """
        【修改】计算雷达图所需指标，并将结果存储在 self.metrics_results 中。
        基准以中证500 (CSI500) 为主（相对基准胜率、信息比率）。
        """
        if daily_returns_df.empty or cumulative_value_df.empty:
            print("每日收益率或累计净值数据为空，无法计算绩效指标。")
            return

        # 假设无风险日收益率 (R_f)
        risk_free_rate_daily = 0.015 / 250
        trading_days_per_year = 250

        strategy_col = '多因子策略'
        csi_col_daily = 'CSI500_Benchmark_Value'  # 用于每日收益率DF

        # --- 基本计算 ---
        total_days = len(daily_returns_df)
        total_return_strategy = (1 + daily_returns_df[strategy_col]).prod() - 1

        annualized_return_strategy = (1 + total_return_strategy) ** (trading_days_per_year / total_days) - 1
        annualized_volatility_strategy = daily_returns_df[strategy_col].std() * np.sqrt(trading_days_per_year)

        # 累计净值序列 (用于最大回撤和最大涨幅)
        cumulative_wealth = cumulative_value_df[strategy_col] / self.initial_capital

        # --- 1. 最大回撤 (Maximum Drawdown) ---
        peak = cumulative_wealth.expanding(min_periods=1).max()
        drawdown = (cumulative_wealth / peak) - 1
        max_drawdown = drawdown.min()  # 这是一个负值

        # --- 2. 区间最大涨幅 (Max Gain over Period) ---
        # 简单定义为净值的 (最大值 / 最小值) - 1，或者更严谨地，任意两点间的最大累计收益
        # 这里采用净值的 (最大值 / 初始值) - 1 来近似，或者直接使用总收益
        # 更严谨的计算 (任意两点最大涨幅)：
        min_wealth = cumulative_wealth.expanding(min_periods=1).min()
        max_gain_series = cumulative_wealth / min_wealth - 1
        max_gain_period = max_gain_series.max()

        # --- 3. 夏普比率 (Sharpe Ratio) ---
        # 使用年化数据
        sharpe_ratio = (annualized_return_strategy - (
                risk_free_rate_daily * trading_days_per_year)) / annualized_volatility_strategy

        # --- 4. Calmar比率 (Calmar Ratio) ---
        # Calmar = 年化收益 / |最大回撤|
        calmar_ratio = annualized_return_strategy / abs(max_drawdown) if abs(max_drawdown) > 0 else np.nan

        # --- 5. 跟踪误差和信息比率 (基准: CSI500) ---
        tracking_difference = daily_returns_df[strategy_col] - daily_returns_df[csi_col_daily]
        tracking_error = tracking_difference.std() * np.sqrt(trading_days_per_year)

        csi_annual_return = (1 + (daily_returns_df[csi_col_daily]).prod()) ** (trading_days_per_year / total_days) - 1
        annual_excess_vs_csi = annualized_return_strategy - csi_annual_return
        information_ratio = annual_excess_vs_csi / tracking_error if tracking_error != 0 else np.nan

        # --- 6. 相对基准胜率 (基准: CSI500) ---
        win_days = (daily_returns_df[strategy_col] > daily_returns_df[csi_col_daily]).sum()
        relative_win_rate = win_days / total_days

        # --- 存储结果 ---
        self.metrics_results = {
            '年化收益率': annualized_return_strategy,
            '年化波动率': annualized_volatility_strategy,
            '区间最大涨幅': max_gain_period,
            '区间最大回撤': abs(max_drawdown),  # 雷达图通常用正值表示回撤的幅度
            '夏普比率': sharpe_ratio,
            'Calmar比率': calmar_ratio,
            '信息比率': information_ratio,
            '相对基准胜率': relative_win_rate
        }

        # --- 打印结果 (保持原有打印格式) ---
        print("\n" + "=" * 50)
        print("======== 策略绩效指标 (雷达图八项指标) ========")
        print("=" * 50)
        for name, value in self.metrics_results.items():
            if name in ['年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤']:
                print(f"{name}: {value * 100:.2f}%")
            elif name == '相对基准胜率':
                print(f"{name}: {value * 100:.2f}%")
            else:
                print(f"{name}: {value:.2f}")
        print("=" * 50)

    def plot_radar(self, benchmark_metrics=None, radar_max_val=1.0):
        # ... (此方法保持不变) ...
        """
        绘制策略相对于某一基准/同类平均的雷达图。
        由于缺乏同类产品数据，此处只绘制策略本身的指标，并使用最大值归一化。
        """
        if not self.metrics_results:
            print("指标数据为空，无法绘制雷达图。请先运行 calculate_metrics。")
            return

        # 确保指标顺序与图片一致 (从上方的"年化收益率"开始，顺时针)
        metrics_order = [
            '年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤',
            'Calmar比率', '信息比率', '相对基准胜率', '夏普比率'  # 夏普比率排在最后以匹配图示
        ]

        # 获取指标值
        values = [self.metrics_results.get(m, 0) for m in metrics_order]

        # 特别处理：波动率、最大回撤是负向指标，需要反转。
        # 这里用最大值归一化，且假设所有指标都越大越好 (除了雷达图中的显示)
        # 实际绘制时，我们只关心其相对大小。

        # 将指标名转为中文，以便绘图
        labels = ['年化收益率', '年化波动率', '区间最大涨幅', '区间最大回撤',
                  '夏普比率', 'Calmar比率', '信息比率', '相对基准胜率']
        # 调整顺序以匹配图片 (图片是 8 个，从上顺时针)
        # 年化收益率 -> 年化波动率 -> 区间最大涨幅 -> 区间最大回撤 -> 夏普比率 -> Calmar比率 -> 信息比率 -> 相对基准胜率
        # (Calmar和夏普位置与图片不完全一致，但雷达图绘制需要特定顺序)

        # 重新排序以匹配图片：
        # 1. 年化收益率 (正)
        # 2. 年化波动率 (负)
        # 3. 区间最大涨幅 (正)
        # 4. 区间最大回撤 (负)
        # 5. 夏普比率 (正)
        # 6. Calmar比率 (正)
        # 7. 信息比率 (正)
        # 8. 相对基准胜率 (正)

        # 修正顺序和标签以匹配图示（顺时针）：
        labels = [
            '超额收益率', '年化波动率',
            '夏普比率', '信息比率', '相对基准胜率'
        ]  # '区间最大涨幅', '区间最大回撤','Calmar比率',

        # 提取并确保顺序：
        values_raw = [
            self.metrics_results['年化收益率'],
            self.metrics_results['年化波动率'],
            # self.metrics_results['区间最大涨幅'],
            # self.metrics_results['区间最大回撤'],  # 最大回撤是正值(幅度)
            # self.metrics_results['Calmar比率'],
            self.metrics_results['信息比率'],
            self.metrics_results['相对基准胜率'],
            self.metrics_results['夏普比率']
        ]

        # 归一化处理：将所有指标归一化到 [0, radar_max_val] 范围
        # 步骤 1: 将所有指标转换为正值（波动率和最大回撤已经确保是正值幅度）
        # 步骤 2: 找到最大值 (Max_All)
        # 步骤 3: 归一化 (Value / Max_All * radar_max_val)

        # 这里使用一个简化的归一化，假设所有值都在 0 到 1 之间（像图示那样）
        # 对于实际的指数增强基金报告，这个刻度通常是相对同类产品的表现分（0-1）
        # 由于我们没有同类数据，我们假设一个归一化因子来使图看起来合理。

        # 示例归一化因子 (这些值是**假设**的，用于将策略值映射到 0-1 的雷达图刻度)
        max_factors = [
            0.3766,  # 年化收益率 (50%)
            0.1984,  # 年化波动率 (30%)
            # 0.2,  # 区间最大涨幅 (100%)
            # 0.30,  # 区间最大回撤 (30%幅度)
            # 1,  # Calmar比率
            29.28,  # 信息比率
            0.1718,  # 相对基准胜率 (70%)
            0.29  # 夏普比率
        ]

        # 归一化值：
        normalized_values = []
        for raw_val, max_factor in zip(values_raw, max_factors):
            # 将策略值除以归一化因子，限制在 [0, 1] 之间
            norm_val = raw_val / max_factor if max_factor != 0 else 0
            # 波动率和最大回撤是负向指标，但图上的点在外圈说明表现好。
            # 在没有同类对比数据的情况下，我们假设雷达图的点越靠近外圈越好，
            # 意味着策略在这两个指标上相对于同类平均表现优秀 (即波动小/回撤小)。
            # 由于我们只画策略，简单取 norm_val，让绘图看起来像图示。

            # 为了使图表看起来合理，我们对波动率和回撤进行**反向归一化**（如果它们是负向指标）：
            # 反转逻辑：1 - (Vol / Max_Vol_Benchmark)
            if labels[len(normalized_values)] in ['年化波动率', '区间最大回撤']:
                # 在没有基准的情况下，暂时不反转，只作归一化。
                normalized_values.append(np.clip(norm_val, 0, 1.0))
            else:
                normalized_values.append(np.clip(norm_val, 0, 1.0))

        # 雷达图需要闭合，因此在数据末尾添加第一个数据点
        values_plot = normalized_values + [normalized_values[0]]

        # 计算角度
        angles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False).tolist()
        angles += angles[:1]

        fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

        # 绘制策略线
        ax.plot(angles, values_plot, linewidth=2, linestyle='solid', color='tab:blue', label='农一中证500指数增强基金')
        ax.fill(angles, values_plot, color='tab:blue', alpha=0.1)

        # 设置标签
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, fontsize=12)

        # 设置刻度 (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)
        ax.set_yticks(np.arange(0, radar_max_val + 0.2, 0.2))
        ax.set_yticklabels([f'{val:.1f}' for val in np.arange(0, radar_max_val + 0.2, 0.2)], color="gray", size=10)
        ax.set_ylim(0, radar_max_val)

        # 调整刻度标签位置
        ax.tick_params(pad=17)

        plt.title('农一中证500指数增强基金绩效雷达图 (归一化)', size=14, y=1.1)
        plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
        plt.show()


# (plot_performance 函数保持不变)
def plot_performance(results_df):
    """绘制投资组合累积收益率图表，新增沪深300。"""
    if results_df is None or results_df.empty:
        print("没有可用于绘制的投资组合回测结果。")
        return

    plt.figure(figsize=(12, 7))

    # 策略颜色和标签映射，新增沪深300
    strategy_config = {
        '多因子策略': {'color': 'brown', 'label': '多因子策略', 'linestyle': '-', 'linewidth': 2},
        'CSI500_Benchmark': {'color': 'black', 'label': '中证500指数 (基准1)', 'linestyle': '--', 'linewidth': 2,
                             'alpha': 0.7},
        'HS300_Benchmark': {'color': 'green', 'label': '沪深300指数 (基准2)', 'linestyle': ':', 'linewidth': 2,
                            'alpha': 0.7}  # 新增
    }

    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            data = results_df[strategy]
            plt.plot(data.index, data.values,
                     color=config['color'],
                     label=config['label'],
                     linestyle=config['linestyle'],
                     linewidth=config['linewidth'],
                     alpha=config.get('alpha', 1))

    # 设置图表样式
    try:
        title_capital = f"初始资金 {tester.initial_capital / 10000:.0f} 万元"
    except NameError:
        title_capital = "初始资金 100 万元"

    plt.title(f'多因子策略 vs. 基准指数 ({title_capital})', fontsize=14, fontweight='bold', pad=15)
    plt.xlabel('日期', fontsize=10)
    plt.ylabel('累积收益率 (%)', fontsize=10)
    plt.legend(fontsize=10, loc='best')
    plt.grid(False)

    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
    plt.gcf().autofmt_xdate()
    plt.axhline(y=0, color='red', linestyle='-', alpha=0.5, linewidth=1)
    plt.tight_layout()
    plt.show()

    print("\n各策略最终累积收益率统计：")
    for strategy, config in strategy_config.items():
        if strategy in results_df.columns:
            final_return = results_df[strategy].iloc[-1]
            print(f"{config['label']}: {final_return:.2f}%")


if __name__ == "__main__":
    # !!! 请根据您的实际文件路径和文件名进行修改 !!!
    data_path = r"C:\Users\cufet\Desktop\测试集"

    STOCK_DATA_FILE = "优化权重结果.xlsx"
    CSI500_INDEX_FILE = "中证500指数日收益率.xls"
    # 新增沪深300数据文件名称 (假设您将其命名为这个)
    HS300_INDEX_FILE = "沪深300指数收盘价.xls"

    try:
        # 实例化类，新增沪深300文件路径
        tester = SimplePortfolioBacktester(data_path, STOCK_DATA_FILE, CSI500_INDEX_FILE, HS300_INDEX_FILE)

        if not tester.price_data.empty and not tester.custom_matrix.empty and not tester.csi500_returns.empty and not tester.hs300_returns.empty:
            print("--- 开始回测 ---")
            portfolio_results_df = tester.run_backtest(
                start_date='2022-12-13',
                end_date='2025-09-30'
            )

            if portfolio_results_df is not None:
                print("--- 结果可视化 ---")
                plot_performance(portfolio_results_df)

                # 【新增】绘制雷达图
                print("--- 雷达图绘制 ---")
                tester.plot_radar(radar_max_val=1.0)  # 设置最大刻度为 1.0

                # 【修改 3：新增导出持仓数据】
                tester._output_holdings_to_excel()

    except Exception as e:
        print(f"分析过程中出现错误: {e}")
